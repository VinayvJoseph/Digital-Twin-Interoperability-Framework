from django.shortcuts import render

from langchain.graphs import Neo4jGraph
from langchain.chains import GraphCypherQAChain
from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate
from langchain_openai import OpenAI
from neo4j import GraphDatabase
import os
import socket

neo4j_ip =[]

# Create your views here.
def process_form(request):
  context = {} # dict to store data that is passed to HTML template
  html_data = DT_data() # DT Network details module
  context['kg_data'] = html_data  # Add DT details to the final data structure that will be passed to HTML template

  # Service-Data Connector module
  if request.method == 'POST':
    submit_button = request.POST.get('submit_button_name')
    if submit_button == 'manager':

      #if compatibility == True, then link data with service.
      source = request.POST.get('source')
      destination = request.POST.get('destination')
      param_S = request.POST.get('param_S')
      param_D = request.POST.get('param_D')
      service_ID = request.POST.get('service_ID')
      operation = request.POST.get('operation')

      # Your logic to process the parameters here (e.g., print them)
      with open("/usr/src/app/shared/data.txt", "w") as f:
        # Write the parameters to the file
        f.write(f"{source}\n")
        f.write(f"{destination}\n")
        f.write(f"{param_S}\n")
        f.write(f"{param_D}\n")
        f.write(f"{service_ID}\n")
        f.write(f"{operation}\n")
    
    # Knowledge Graph Query module
    elif submit_button == 'KG':
      button_ip = request.POST.get('ip')

      # Neo4j connection details
      url = "bolt://" + button_ip + ":7687"
      #url = "bolt://131.155.223.243:7687"
      username ="neo4j"
      password = "digitaltwin"
    
      # Establishes a connection between langchain and Neo4j graph by creating a graph object that LangChain can use.
      # Schema of the graph is imbibed by LangChain.
      graph = Neo4jGraph(
        url=url, 
        username=username, 
        password=password
      )

      # OpenAI API key
      os.environ['OPENAI_API_KEY'] = "Populate with your key"

      # Refreshes the imported schema to be up to date with changes in the neo4j database.
      graph.refresh_schema()

      # Using CYPHER to query for information from the neo4j database.'GraphCypherQAChain' aids in formulating the cypher query
      cypher_chain = GraphCypherQAChain.from_llm(
      cypher_llm = ChatOpenAI(temperature=0, model_name='gpt-4o'), # LLM to construct CYPHER query
      qa_llm = ChatOpenAI(temperature=0), graph=graph, verbose=True, # LLM to create an output response based on data generated by the CYPHER query
      )

      # Send the query for processing
      query = request.POST.get('query')

      # Receive and parse the result.
      result_dict = cypher_chain.invoke({"query": query})
      question = result_dict["query"]
      answer = result_dict["result"]

      # Pass the message to the template context
      context['answer'] = answer 
      context['question'] = question

  return render(request, 'form_advanced.html', context)  # Display the form if not a POST request
    
#-----------------------------------------HELPER FUNCTIONS -------------------------------------------------

def query_KG(kg_ip, param):
  URI = "bolt://" + kg_ip + ":7687"
  AUTH = ("neo4j", "digitaltwin")

  # Verify connectivity to Neo4j Database
  with GraphDatabase.driver(URI, auth=AUTH) as driver:
    driver.verify_connectivity()

  # Get all details of the node
  records, summary, keys = driver.execute_query(
    "MATCH (n:Parameter) WHERE n.id = $id RETURN n",
        id = param, database_="neo4j",
    )  

  node_record = records[0]['n']
  node_properties = dict(node_record)  # Convert Node to dictionary
  node_properties_string = str(node_properties)

  return node_properties_string


def read_data():
  data_points = []  # Create an empty list to store data points
  try:
    with open("/usr/src/app/shared/neo4j_ip.txt", "r") as f:
      for line in f:
        # Read each line and append it to the list
        data_points.append(line.strip())  # Remove trailing newline character
  except FileNotFoundError:
    return None

  return data_points

def DT_data():
  neo4j_ip = read_data()
  html_data = [] # List which holds multiple dictionaries
  if neo4j_ip is not None:
    for ip in neo4j_ip:
      URI = "bolt://" + ip + ":7687"
      AUTH = ("neo4j", "digitaltwin")
    
      # Verify connectivity to Neo4j Database
      with GraphDatabase.driver(URI, auth=AUTH) as driver:
        driver.verify_connectivity()

      line = {} # Dictionary to store data for one row

      # Query for 'Digital Twin' data from Knowldge Graph
      records, summary, keys = driver.execute_query(
      "MATCH (p:DigitalTwin) RETURN p.name as dt_name, p.description as dt_description",
          database_="neo4j",
      )
      driver.close()

      # Extract global_id from record.
      line['dt_name'] = records[0]['dt_name']
      line['dt_description'] = records[0]['dt_description']

      # Query for 'Client' data from Knowldge Graph
      records, summary, keys = driver.execute_query(
      "MATCH (p:Client) RETURN p.name as name, p.description as description, p.global_id as id",
          database_="neo4j",
      )
      driver.close()

      client_list =[]
      client_id = []
      length = len(records)
      for i in range(length):
          test = records[i]['name'] + ':' + records[i]['description']
          client_list.append(test)
          client_id.append(records[i]['id'])

      line['clients'] = client_list
      line['client_ids'] = client_id
      line['kg_ip'] = ip

      html_data.append(line) # Final list containing all data

  return html_data

def clear_data():
  try:
    with open("/usr/src/app/shared/neo4j_ip.txt", 'w') as f:
      # Write an empty string to clear the file content
      f.write("")
    return True
  except FileNotFoundError:
    print(f"File not found:")
    return False
  except Exception as e:
    print(f"An error occurred: {e}")
    return False